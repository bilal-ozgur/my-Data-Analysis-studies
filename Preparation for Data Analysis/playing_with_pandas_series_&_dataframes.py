# -*- coding: utf-8 -*-
"""Playing with Pandas Series & DataFrames.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Rvl1AqaR8g3DKBxTai_w0NS0-iPn7zPP

___

<p style="text-align: center;"><img src="https://docs.google.com/uc?id=1lY0Uj5R04yMY3-ZppPWxqCr5pvBLYPnV" class="img-fluid" 
alt="CLRSWY"></p>

## <p style="background-color:#FDFEFE; font-family:newtimeroman; color:#9d4f8c; font-size:100%; text-align:center; border-radius:10px 10px;">WAY TO REINVENT YOURSELF</p>

<img src=https://i.ibb.co/6gCsHd6/1200px-Pandas-logo-svg.png width="700" height="200">

## <p style="background-color:#FDFEFE; font-family:newtimeroman; color:#060108; font-size:200%; text-align:center; border-radius:10px 10px;">Data Analysis with Python</p>

## <p style="background-color:#FDFEFE; font-family:newtimeroman; color:#060108; font-size:150%; text-align:center; border-radius:10px 10px;">Lab-04Session</p>

## <p style="background-color:#FDFEFE; font-family:newtimeroman; color:#4d77cf; font-size:200%; text-align:center; border-radius:10px 10px;">Playing with Pandas Series & DataFrames</p>

<a id="toc"></a>

## <p style="background-color:#9d4f8c; font-family:newtimeroman; color:#FFF9ED; font-size:175%; text-align:center; border-radius:10px 10px;">Content</p>

* [OVERVIEW](#0)
* [IMPORTING LIBRARIES NEEDED IN THIS NOTEBOOK](#1)
* [CREATING NUMPY ARRAYS](#2)
* [WORKING WITH SERIES DATA STRUCTURE](#3)
* [CREATING A PANDAS DATAFRAMES](#4)
* [WORKING WITH DATAFRAMES](#5)
* [INDEXING, SLICING & SELECTION](#6)
* [THE END OF THE LAB-01 SESSION](#7)

## <p style="background-color:#9d4f8c; font-family:newtimeroman; color:#FFF9ED; font-size:175%; text-align:center; border-radius:10px 10px;">Overview</p>

<a id="0"></a>
<a href="#toc" class="btn btn-primary btn-sm" role="button" aria-pressed="true" 
style="color:blue; background-color:#dfa8e4" data-toggle="popover">Content</a>

## What is Pandas in Python?

[**Pandas**](http://pandas.pydata.org/) is the most famous python library providing fast, flexible, and expressive data structures designed to make working with "relational" or "labeled" data both easy and intuitive. It aims to be the fundamental high-level building block for doing practical, real world data analysis in Python. Additionally, it has the broader goal of becoming the most powerful and flexible open source data analysis / manipulation tool available in any language. It is already well on its way towards this goal.

In Pandas, the data is usually utilized to support the statistical analysis in SciPy, plotting functions from Matplotlib, and machine learning algorithms in Scikit-learn.

Its popularity has surged in recent years, coincident with the rise of fields such as data science and machine learning. Here’s a popularity comparison over time against STATA, SAS, and [dplyr](https://dplyr.tidyverse.org/) courtesy of Stack Overflow Trends

<img src="https://i.ibb.co/crf3ksp/pandas-vs-rest.png" style="">

## Core Components of Pandas Data Structure

Organizing any data in a particular way is known as a data structure. **``Pandas``** have **two core data structure** components, and all operations are based on those two objects. Here are the two pandas data structures:

  - [**Series :**](https://pandas.pydata.org/docs/reference/api/pandas.Series.html) A kind of one-dimensional array of any data type that we specified in the pandas module.
  - [**DataFrame :**](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html) a 2 dimensional data structure, like a 2 dimensional array, or a table with rows and columns of potentially different types.

## Main Features

Just as [**NumPy**](http://www.numpy.org/) provides the basic array data type plus core array operations, **``Pandas``**;

1. defines fundamental structures for working with data and  
1. endows them with methods that facilitate operations such as  
  
  - reading in data  
  - adjusting indices  
  - working with dates and time series  
  - sorting, grouping, re-ordering and general data munging <sup><a href=#mung id=mung-link>[1]</a></sup>  
  - dealing with missing values, etc., etc.  
  
Here are just a few of the things that pandas does well:

  - Easy handling of [missing data](https://pandas.pydata.org/pandas-docs/stable/user_guide/missing_data.html) (represented as **``NaN``**) in floating point as well as non-floating point data
  - Size mutability: columns can be [inserted and deleted](https://pandas.pydata.org/pandas-docs/stable/user_guide/dsintro.html) from DataFrame and higher dimensional objects
  - Automatic and explicit [data alignment](https://pandas.pydata.org/pandas-docs/stable/user_guide/dsintro.html): objects can be explicitly aligned to a set of labels, or the user can simply ignore the labels and let **``Series``**, **``DataFrame``**, etc. automatically align the data for you in computations
  - Powerful, flexible [group by](https://pandas.pydata.org/pandas-docs/stable/user_guide/groupby.html) functionality to perform split-apply-combine operations on data sets, for both aggregating and transforming data
  - Make it [easy to convert](https://pandas.pydata.org/pandas-docs/stable/user_guide/dsintro.html) ragged, differently-indexed data in other Python and NumPy data structures into DataFrame objects
  - Intelligent label-based [slicing](https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html), [fancy indexing](https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html), and [subsetting](https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html) of large data sets
  - Intuitive [merging](https://pandas.pydata.org/pandas-docs/stable/user_guide/merging.html) and [joining](https://pandas.pydata.org/pandas-docs/stable/user_guide/merging.html) datasets
  - Flexible [reshaping](https://pandas.pydata.org/pandas-docs/stable/user_guide/reshaping.html) and [pivoting](https://pandas.pydata.org/pandas-docs/stable/user_guide/reshaping.html) of datasets
  - [Hierarchical labeling](https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html) of axes (possible to have multiple labels per tick)
  - Robust IO tools for loading data from [flat files](https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html) (CSV and delimited), [Excel files](https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html), [databases](https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html), and saving/loading data from the ultrafast [HDF5 format](https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html)
  - [Time series](https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html)-specific functionality: date range generation and frequency conversion, moving window statistics, moving window linear regressions, date shifting and lagging, etc.

More sophisticated statistical functionality is left to other packages, such as [statsmodels](http://www.statsmodels.org/) and [scikit-learn](http://scikit-learn.org/), which are built on top of pandas.

This session will provide a basic introduction to Pandas. Throughout the session, we will assume that the following imports have taken place.

## <p style="background-color:#9d4f8c; font-family:newtimeroman; color:#FFF9ED; font-size:175%; text-align:center; border-radius:10px 10px;">Importing Libraries Needed in This Notebook</p>

<a id="1"></a>
<a href="#toc" class="btn btn-primary btn-sm" role="button" aria-pressed="true" 
style="color:blue; background-color:#dfa8e4" data-toggle="popover">Content</a>

Once you've installed NumPy & Pandas you can import them as a library:
"""

import numpy as np
import pandas as pd

# pd.options.display.float_format = '{:20,.2f}'.format  # Suppressing scientific notation in pandas

df = pd.DataFrame(np.random.random(5)**10, columns=["random"])
df

print(1.203782e-03 == 0.001203782)
print(1.088712e-05 == 0.00001088712)
print(9.880200e-09 == 0.000000009880200)
print(6.883080e-07 == 0.0000006883080)
print(9.150161e-07 == 0.0000009150161)

# Solution-1 --> round()function

print(df.round(2))
# print(df.round(3))
# print(df.round(4))
# print(df.round(5))
# print(df.round(5))

# For numpy arrays

arr = np.random.random(5)**10
print(arr)
print("---"*10)
print(np.round(arr,3))

# Solution-2

pd.options.display.float_format = '{:20,.4f}'.format
df

# For numpy arrays

print(arr)
print("---"*10)
np.set_printoptions(suppress=True)
print(arr)
print("---"*10)
np.set_printoptions(precision=4)
print(arr)

np.set_printoptions(precision=None, suppress=None)

pd.options.display.float_format = '{:20,.2f}'.format  # Suppressing scientific notation in pandas

"""## <p style="background-color:#9d4f8c; font-family:newtimeroman; color:#FFF9ED; font-size:175%; text-align:center; border-radius:10px 10px;">Creating Numpy Arrays</p>

<a id="2"></a>
<a href="#toc" class="btn btn-primary btn-sm" role="button" aria-pressed="true" 
style="color:blue; background-color:#dfa8e4" data-toggle="popover">Content</a>

**``NumPy``**, which stands for Numerical Python, is a library consisting of multidimensional array objects. **``Numpy Array``** is the foundation for all data science in Python. Arrays can be multidimensional, and all elements in an array need to be of the same type, all integers or all floats. Python lists are a substitute for arrays, but they fail to deliver the performance required while computing large sets of numerical data.

**Advantages of using an Array**
* Arrays can handle very large datasets efficiently
* Computationally-memory efficient
* Faster calculations and analysis than lists
* Diverse functionality (many functions in Python packages). With several Python packages that make trend modeling, statistics, and visualization easier.

**You can create a basic Array by calling** **``numpy.array()``**.

**``numpy.array(object, dtype=None, *, copy=True, order='K', subok=False, ndmin=0, like=None)``**

**``Pandas Series``** is a **one-dimensional** data structure. It can hold data of many types including **``objects``**, **``floats``**, **``strings``** and **``integers``**. You can create a Series by calling **``pandas.Series()``**. A **``list``**, **``numpy array``**, **``dict``** can be turned into a **``Pandas Series``**. You should use the simplest data structure that meets your needs [Source](https://pythonbasics.org/pandas-series/). The **``axis labels``** are collectively called **``index``**. **``Labels``** need not to be unique but must be a [**hashable type**](https://stackoverflow.com/questions/14535730/what-does-hashable-mean-in-python#:~:text=In%20Python%2C%20any%20immutable%20object,sets%20to%20track%20unique%20values.). The object supports both integer and label-based indexing and provides a host of methods for performing operations involving the index [Source](https://www.geeksforgeeks.org/creating-a-pandas-series/).

**``Series``** and **``DataFrame``** are two important data types defined by Pandas.

You can think of a Series as a “column” of data, such as a collection of observations on a single variable.

A DataFrame is an object for storing related columns of data or combination of Series.

**``A Series``** holding a variety of object types is a **one-dimensional data structure** and **homogeneous**; that is, all data are of the same type and are implicitly labelled with an index. For example, we can have a Series of integers, real numbers, characters, strings, dictionaries, etc. We can conveniently manipulate these series performing operations like adding, deleting, ordering, joining, filtering, vectorized operations, statistical analysis, plotting, etc. 

**``A Series``** is very **similar to a NumPy array** (in fact it is built on top of the NumPy array object). **What differentiates** the NumPy array from a Series, is that a Series can **have axis labels**, meaning it can be indexed by a label, instead of just a number location. It also doesn’t need to hold numeric data, it can hold any arbitrary Python Object [Source](http://www.datasciencelovers.com/python-for-data-science/pandas-series/).

So important point to remember for Pandas series is:

- Homogeneous data
- Size Immutable
- Values of Data Mutable

**You can create a Series by calling** **``pandas.Series()``**. A **``list``**, **``numpy array``**, **``dict``** can be turned into a Pandas Series.

**``pd.Series(data=None, index=None, dtype=None, name=None, copy=False, fastpath=False)``**

<span style="color:blue">**Create a basic Numpy Array named "my_array" using the following list.**</span>

[0, 1, 2, 3, 4]
"""

# YOUR CODE IS HERE

my_array = np.array([0, 1, 2, 3, 4])
my_array

"""<span style="color:blue">**Create an empty NumPy array named "empty_array" of (3, 4) shape including integers.**</span>"""

# YOUR CODE IS HERE

empty_array = np.empty((3, 4), dtype=int)
empty_array

"""Desired Output:

array([[0, 0, 0, 0],
       [0, 0, 0, 0],
       [0, 0, 0, 0]])
"""

# Same output with NP.ZEROS 
# difference between NP.ZEROS ile NP.EMPTY

zero_array = np.zeros((3, 4), dtype=int)
zero_array

np.empty((2, 2))

np.empty([2,2])

"""<span style="color:blue">**Create a full NumPy array of named "full_array" (3, 3) shape including 99.99 floating points.**</span>"""

# YOUR CODE IS HERE

full_array = np.full(shape=(3, 3), fill_value = 99.99, dtype=float)
full_array

# For keyword-positional argumnet example

full_array = np.full((3, 3), 99.99, dtype=float)
full_array

# For keyword-positional argumnet example

full_array = np.full(dtype=float, (3, 3), 99.99)
full_array

# For keyword-positional argumnet example

full_array = np.full(dtype=float, shape=(3, 3), fill_value=99.99)
full_array

"""## <p style="background-color:#9d4f8c; font-family:newtimeroman; color:#FFF9ED; font-size:175%; text-align:center; border-radius:10px 10px;">Creating a Pandas Series</p>

<a id="2"></a>
<a href="#toc" class="btn btn-primary btn-sm" role="button" aria-pressed="true" 
style="color:blue; background-color:#dfa8e4" data-toggle="popover">Content</a>



**You can create a Series by calling** **``pandas.Series()``** . A **``list``**, **``numpy array``**, **``dict``** can be turned into a Pandas Series.

**``pd.Series(data=None, index=None, dtype=None, name=None, copy=False, fastpath=False)``**
"""

# From a list

my_list = [10, 20, 30, 40, 50]
series_from_list = pd.Series(my_list)
series_from_list

# From a numpy array

my_array = np.array([10, 20, 30, 40, 50])
series_from_array = pd.Series(my_array)
series_from_array

# From a Dictionary

my_dict = {'A': 10, 'B': 20, 'C': 30}
series_from_dict = pd.Series(my_dict)
series_from_dict

# Using a Scalar Value

scalar_value = 5
series_from_scalar = pd.Series(scalar_value, index=['A', 'B', 'C', 'D'])
series_from_scalar

# Using a Range of Values

series_range = pd.Series(range(1, 6))
series_range

# Using Custom Index Labels

data = [10, 20, 30, 40, 50]
custom_index = ['A', 'B', 'C', 'D', 'E']
series_custom_index = pd.Series(data, index=custom_index)
series_custom_index

# Pandas serie with mixed data

mixed_data = [10, 'Hello', 3.14, True]
series_mixed_data = pd.Series(mixed_data, dtype=object)
series_mixed_data

series_mixed_data.dtype

for i in series_mixed_data:
    print(type(i))

"""<span style="color:blue">**Create a Pandas Series named "my_series" using the following list.**</span>

['a', 'b', 'c', 'd', 'e']
"""

my_arr = np.array(['a', 'b', 'c', 'd', 'e'])
my_arr

my_arr[0]

# YOUR CODE IS HERE

my_series = pd.Series(['a', 'b', 'c', 'd', 'e'])
my_series

"""Desired Output:

0    a
1    b
2    c
3    d
4    e
dtype: object
"""

my_series[0]

"""One of the essential pieces of NumPy is the ability to perform quick element-wise operations, both with basic arithmetic (addition, subtraction, multiplication, etc.) and with more sophisticated operations (trigonometric functions, exponential and logarithmic functions, etc.). 

**``Pandas Series``** **are built on top of** **``NumPy arrays``** **and support many** **``similar operations:``**
"""

my_list = [1, 2, 3, 4]
my_list * 3

my_arr = np.array(my_list)
my_arr * 3

my_ser = pd.Series(my_list)
my_ser * 3

"""In mathematics, element-wise operations refer to operations on individual elements of a matrix. Any arithmetic operations in arrays applies the operation elementwise. **[NumPy Basics: Arrays and Vectorized Computation](https://www.oreilly.com/library/view/python-for-data/9781449323592/ch04.html)** & **[Numerical Operations on Arrays](https://scipy-lectures.org/intro/numpy/operations.html)**"""

my_series * 100

"""<span style="color:blue">**Create a random Pandas Series of float numbers and name this Series as "Daily Returns".**</span>"""

# YOUR CODE IS HERE

daily_returns = pd.Series(np.random.randn(4), name='Daily Returns')
daily_returns

"""Desired Output:

0                  -0.52
1                   0.80
2                  -0.45
3                  -0.26
Name: Daily Returns, dtype: float64
"""

daily_returns[daily_returns > 0]

daily_returns[daily_returns < 0]

daily_returns + 5

daily_returns - 1

daily_returns * 2

daily_returns / 3

daily_returns.std()

# degrees of freedom

np.std(daily_returns)

daily_returns.mean()

np.mean(daily_returns)

daily_returns.median()

np.median(daily_returns)

"""## <p style="background-color:#9d4f8c; font-family:newtimeroman; color:#FFF9ED; font-size:175%; text-align:center; border-radius:10px 10px;">Working with Series Data Structure</p>

<a id="3"></a>
<a href="#toc" class="btn btn-primary btn-sm" role="button" aria-pressed="true" 
style="color:blue; background-color:#dfa8e4" data-toggle="popover">Content</a>

**SOME COMMON ATTRIBUTES** [Official Pandas API Document](https://pandas.pydata.org/docs/reference/api/pandas.Series.html)<br>

**Series.dtype**	It returns the data type of the data.<br>
**Series.shape**	It returns a tuple of shape of the data.<br>
**Series.size**	    It returns the size of the data.<br>
**Series.ndim**	    It returns the number of dimensions in the data.<br>
**Series.index**	Defines the index of the Series.<br>
**Series.keys**  	Return alias for index.<br>
**Series.values**   Returns Series as ndarray or ndarray-like depending on the dtype.<br>
**Series.items**	Lazily iterate over (index, value) tuples.<br>
**Series.head**   	Return the first n rows.<br>
**Series.tail** 	Return the last n rows.<br>
**Series.sample**   Return a random sample of items from an axis of object.<br>
**Series.sort_index**  Sort Series by index labels.<br>
**Series.sort_values**  Sort by the values.<br>
**Series.isin**     Whether elements in Series are contained in values.<br>
"""

games = pd.read_csv("vgsalesGlobale.csv")
games

type(games)

games.Name

games["Name"]

type(games.Name)

# Defines the index of the Series.

games["Name"].index

games.index

# Returns Series as ndarray or ndarray-like depending on the dtype

games["Name"].values

# It returns alias for index

games["Name"].keys

games.Name.keys()

# It returns the data type of the data.

games["Name"].dtype

games.dtypes

# It returns a tuple of shape of the data.

games["Name"].shape

# It returns the size of the data.

games["Name"].size

# It returns the number of dimensions in the data.

games["Name"].ndim

# It returns True if Series object is empty, otherwise returns false.

games["Name"].empty

# It returns True if there are any NaN values, otherwise returns false.

games["Name"].hasnans

# It returns the number of bytes in the data.

games["Name"].nbytes

games.memory_usage(index=True, deep=False)

"""**SOME COMMON METHODS & FUNCTIONS** [Official Pandas API Document](https://pandas.pydata.org/docs/reference/api/pandas.Series.html)<br>

**Series.head(n)**	It returns the first n rows of the series.<br>
**Series.tail(n)**	It returns the last n rows of the series.<br>
**Series.sample(n)**	It returns the n randomized sample from series.<br>
**Series.describe()**	Generates descriptive statistics of the series, including count, mean, standard deviation, minimum, maximum, and quartiles.<br>
**Series.unique()**	Returns a sorted array of unique values in the series.<br>
**Series.value_counts()**  	Computes a frequency count of each unique value in the series.<br>
**Series.sort_values()**   Sorts the series by its values.<br>
**Series.sort_index()**	Sorts the series by its index.<br>
**Series.isnull()**   	 Returns a boolean series indicating which values are missing (null/NaN).<br>

[**head(n=5)**](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.head.html) function returns the first n rows for the object based on position. It is useful for quickly testing if your object has the right type of data in it.

For negative values of n, this function returns all rows except the last n rows, equivalent to df[:-n].
"""

games["Name"].head()

"""**[tail()](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.tail.html)** function returns last n rows from the object based on position. It is useful for quickly verifying data, for example, after sorting or appending rows."""

games["Name"].tail()

"""**[sample()](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.sample.html)** function returns a random sample of items from an axis of object."""

games["Name"].sample(5)

"""**[describe()](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.describe.html)** generates descriptive statistics. Descriptive statistics include those that summarize the central tendency, dispersion and shape of a dataset’s distribution, excluding NaN values.

Analyzes both numeric and object series, as well as DataFrame column sets of mixed data types.
"""

games.Genre.describe()

games.NA_Sales.describe()

"""**[unique()](https://pandas.pydata.org/docs/reference/api/pandas.unique.html)** returns unique values based on a hash table. Uniques are returned in order of appearance. """

games["Genre"].unique()

"""**[nunique(a)](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.nunique.html)** Count number of distinct elements in specified axis. Return Series with number of distinct elements. Can ignore NaN values."""

games["Genre"].nunique()

"""[**value_counts()**](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.value_counts.html) returns **``a Series``** containing counts of **``unique values``** (which counts everything except the nan rows).

The resulting object will be in descending order so that the first element is the most frequently-occurring element. Excludes NA values by default.
"""

type(games.Genre.value_counts())

games.Publisher.value_counts().head(50)

"""You can still use **``value_counts()``** but with **``dropna=False``** rather than True (the default value), as follows:

**``P.S.``** Interestingly enough, pd.Series.value_counts method also supports dropna argument, but pd.DataFrame.value_counts method does not
"""

games.Publisher.value_counts(dropna=False).head(50)

"""With normalize set to True, returns the relative frequency by dividing all values by the sum of values."""

games.Genre.value_counts(normalize=True)

"""20% of the computer games sold are action games

<span style="color:blue">**What if we have many unique values at the feature we are interested in?**</span>

**``bin``** parameter inside value_counts() is probably the most underutilized one. value_counts() can be used to bin continuous data into discrete intervals with the help of the bin parameter. This option works only with numerical data. It is similar to the **``pd.cut()``** function.
"""

games.EU_Sales.value_counts()

"""Using value_counts() in a plain way sometimes doesn’t convey much information as the output contains a lot of categories for every value of related feature. Instead, let’s group them into 4 bins."""

games.EU_Sales.value_counts(bins=4) 

# print(games.EU_Sales.min())
# print(games.EU_Sales.max())

"""Binning makes it easy to understand the idea being conveyed. We can easily see that most of the gamers in EU paid less than 7.255 for their games. Also, we can see that having four bins serves our purpose since no sales falls into the last bin.

**[sort_values()](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.sort_values.html)** sorts by the values along either axis.
"""

games.EU_Sales.sort_values()

"""**[sort_index()](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.sort_index.html)** sorts object by labels (along an axis). Returns a new DataFrame sorted by label if inplace argument is False, otherwise updates the original DataFrame and returns None."""

games.EU_Sales.sort_index()

"""**[isnull()](https://pandas.pydata.org/docs/reference/api/pandas.isnull.html)** detects missing values for an array-like object. This function takes a scalar or array-like object and indicates whether values are missing (NaN in numeric arrays, None or NaN in object arrays, NaT in datetimelike)."""

games["Year"].isnull()

games["Year"].isnull().sum()

"""## <p style="background-color:#9d4f8c; font-family:newtimeroman; color:#FFF9ED; font-size:175%; text-align:center; border-radius:10px 10px;">Creating a Pandas DataFrames</p>

<a id="4"></a>
<a href="#toc" class="btn btn-primary btn-sm" role="button" aria-pressed="true" 
style="color:blue; background-color:#dfa8e4" data-toggle="popover">Content</a>

Pandas DataFrame is a 2-dimensional labeled data structure with columns of potentially different types. It is generally the most commonly used pandas object. Pandas DataFrame can be created in multiple ways:

  - Creating Pandas DataFrame from lists of lists.
  - Creating DataFrame from dict of narray/lists.
  - Creating Dataframe from list of dicts.
  - Creating DataFrame using zip() function.
  - Creating DataFrame from Dicts of series.
  
[Source](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html), [Source](https://www.javatpoint.com/how-to-create-a-dataframes-in-python), [Source](https://towardsdatascience.com/15-ways-to-create-a-pandas-dataframe-754ecc082c17)

**Let's remember how to create a DataFrame in Pandas:**
"""

data = {"name":["Bill", "Tom", "Tim", "John", "Alex", "Vanessa", "Kate"],
        "score":[90, 80, 85, 75, 95, 60, 65],
        "sport":["Wrestling", "Football", "Skiing", "Swimming", "Tennis", "Karete", "Surfing"],
        "sex":["M", "M", "M", "M", "F", "F", "F"]}
data

"""**pandas.DataFrame(data=None, index=None, columns=None, dtype=None, copy=None)** [Official Pandas API](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html)"""

df = pd.DataFrame(data)
df

"""As seen, we have created a Dictionary and assigned it to an object named "data".

## <p style="background-color:#9d4f8c; font-family:newtimeroman; color:#FFF9ED; font-size:175%; text-align:center; border-radius:10px 10px;">Working with DataFrames</p>

<a id="5"></a>
<a href="#toc" class="btn btn-primary btn-sm" role="button" aria-pressed="true" 
style="color:blue; background-color:#dfa8e4" data-toggle="popover">Content</a>

While a `Series` is a single column of data, a `DataFrame` is several columns, one for each variable.

In essence, a `DataFrame` in pandas is analogous to a (highly optimized) Excel spreadsheet.

The two main data structures in pandas both have at least one axis. A **Series** has **one axis**, the index. A **DataFrame** has **two axes**, the index and the columns. It’s useful to note here that in all the DataFrame functions that can be applied to either rows or columns, an axis of 0 refers to the index, an axis of 1 refers to the columns.

Thus, it is a powerful tool for representing and analyzing data that are naturally organized into rows and columns, often with  descriptive indexes for individual rows and individual columns.

Let’s look at an example that reads data from the CSV file named `test_lab.csv`.
"""

df = pd.read_csv('test_lab.csv')
print(f"\033[1mThe type of test_lab.csv is\033[0m {type(df)}")
df

"""[**info()**](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.info.html) prints a concise summary of a DataFrame. This method prints information about a DataFrame including the number of columns, column labels, column data types, memory usage, range index, and the number of cells in each column (non-null values)."""

df.info()

df.shape

df.size

df.ndim

df.columns

df.keys()

"""## <p style="background-color:#9d4f8c; font-family:newtimeroman; color:#FFF9ED; font-size:175%; text-align:center; border-radius:10px 10px;">Indexing, Slicing & Selection</p>

<a id="6"></a>
<a href="#toc" class="btn btn-primary btn-sm" role="button" aria-pressed="true" 
style="color:blue; background-color:#dfa8e4" data-toggle="popover">Content</a>

As stated and implemented by examples above, a Series is very similar to a NumPy array. [**What differentiates the NumPy array from a Series**](https://www.educba.com/pandas-vs-numpy/) is that **a Series can have axis labels**, meaning it can be indexed by a label, instead of just a number location. In otherwords, the essential difference is **the presence of the index**: while the **``Numpy Array``** has an implicitly defined integer index used to access the values, the **``Pandas Series``** has an explicitly defined index associated with the values (labels). Moreover, it doesn NOT need to hold numeric data, it can hold any arbitrary Python Object [Source](https://rpubs.com/pjozefek/659184).

So, the key to using a Series is understanding its index. Pandas makes use of these index names or numbers by allowing for fast look up of information.

The axis labeling information in pandas objects serves many purposes:

- Identifies data (i.e. provides metadata) using known indicators, important for analysis, visualization, and interactive console display.
- Enables automatic and explicit data alignment.
- Allows intuitive getting and setting of subsets of the data set.

In this part of our session, we will focus on the final point: namely, how to slice, dice, and generally get and set subsets of pandas objects. The primary focus will be on Series and DataFrame as they have received more development attention in this area. For more information, please visit [pandas-docs.github.io](https://pandas-docs.github.io/pandas-docs-travis/user_guide/indexing.html)

The most robust and consistent way of slicing ranges along arbitrary axes is described in the [Selection by Position](https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#indexing-integer) section detailing the .iloc method. First, let us look at the semantics of slicing using the **[ ]** operator.

[Some More Examples](https://sparkbyexamples.com/pandas/how-to-slice-columns-in-pandas-dataframe/#:~:text=By%20using%20pandas.,columns%2C%20the%20syntax%20is%20df.)
"""

df["country"]

df[['country', 'POP']]

df[:][['country', 'POP']]

df[2:4][['country', 'POP']]

type(df['country'])

df['country']

df[['country']]

df[['country','POP']]

"""### [.loc[ ]](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.loc.html) → allows us to select data using **labels** (names) of rows (index) & columns

### [.iloc[ ]](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.iloc.html) → allows us to select data using **index numbers** of rows (index) & columns. it's like classical indexing logic

Let us first remember our df: 
"""

df

df.iloc[2:5]

df.loc[2:5]

"""### **``QUESTION:``** **What happened? Why was South Africa included when** **``loc``** **used?**

The first thing remembered is that **``.iloc[ ]``** is **exclusive** while **``.loc[ ]``** is **inclusive.**

## 1) **``Using Pandas.DataFrame.loc[]``** (By label)


**1.1 – Slicing Columns by Names or Labels**

By using **``pandas.DataFrame.loc[ ]``** you can slice columns by names or labels. To slice the columns, the syntax is **``df.loc[:, start:stop:step]``**; where start is the name of the first column to take, stop is the name of the last column to take, and step as the number of indices to advance after each extraction
"""

df.loc[:, "country":"POP"]

df.loc[2:6, "country":"POP"]

"""**1.2 – Slicing DataFrame Columns by Labels**

To slice DataFrame columns by labels or names, all you need is to provide the multiple labels you wanted to slice as a list. Here we use the list of labels instead of the start:stop:step approach.
"""

df.loc[:, ['country', 'country isocode', 'year', 'POP']]

df.loc[:, ('country', 'country isocode', 'year', 'POP')]

"""**1.3 – Slicing DataFrame Columns by Range**

When you wanted to slice a DataFrame by the range of columns, provide start and stop column names.

  - By not providing a start column, loc[] selects from the beginning.
  - By not providing stop, loc[] selects all columns from the start label.
  - Providing both start and stop, selects all columns in between.
"""

# Slicing all columns between "country" an 'POP' columns

df.loc[:, 'country':'POP']

# Slicing by start from 'country isocode' column

df.loc[:, 'country isocode':]

# Slicing by start from the beginning and end at 'XRAT' column

df.loc[:, :'XRAT']

"""**1.4 – Slicing Certain Selective Columns in pandas**

Sometimes you may want to select random certain columns from pandas DataFrame, you can do this by passing selected column names/labels as a list.
"""

df.loc[:, ['country', 'year', 'POP']]

"""**1.5 – Selecting Every Alternate Column**

Using **``loc[ ]``**, you can also slice columns by selecting every other column from pandas DataFrame.
"""

df.loc[:, ::2]

"""## 2) **``Using Pandas.DataFrame.iloc[]``** (By position)

By using **``pandas.DataFrame.iloc[ ]``** you can slice DataFrame by column **position/index**. Always remember that index starts from 0. You can use **``pandas.DataFrame.iloc[ ]``** with the syntax **``[:, start:stop:step]``**; where **start** indicates the index of the first column to take, **stop** indicates the index of the last column to take, and **step** indicates the number of indices to advance after each extraction. Or, use the syntax: **``[:, [indices]]``** with indices as a list of column indices to take.

**2.1 – Slicing Columns by Index Position**
"""

# Let us first remember our df

df

"""We are going to use columns by their index positions, and retrieve slices of DataFrame. Below example retrieves "country isocode", "POP" and "XRAT" slices of columns at the DataFrame."""

# Slicing by selected column position

df.iloc[:, [1, 3, 4]]

"""**2.2 Column Slices by Position Range**

Like slices by column labels, you can also slice a DataFrame by a range of positions.
"""

# Slicing between indexes 1 (inclusive) and 4 (exclusive)

df.iloc[:, 1:4]

# Slicing from the 3rd index (inclusive) to end

df.iloc[:, 3:]

# Slicing from the beginning to the 2nd index (exclusive)

df.iloc[:, :2]

"""To get the **last column** use **``df.iloc[:, -1:]``** and to get just **first column** **``df.iloc[:, :1]``**"""

df.iloc[:, -1]

"""## BONUS"""

df

df.iat[2, 3]  # By position

df.at[2, "POP"]  # By label

"""**``iat[]``** and **``at[]``** gives only a single value output (working with scalar only), so very fast, while **``iloc[]``** and **``loc[]``** can give multiple row output. [Source](https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html)

## <p style="background-color:#FDFEFE; font-family:newtimeroman; color:#9d4f8c; font-size:150%; text-align:center; border-radius:10px 10px;">The End of The Lab-04 Session</p>

<a id="7"></a>
<a href="#toc" class="btn btn-primary btn-sm" role="button" aria-pressed="true" 
style="color:blue; background-color:#dfa8e4" data-toggle="popover">Content</a>

<p style="text-align: center;"><img src="https://docs.google.com/uc?id=1lY0Uj5R04yMY3-ZppPWxqCr5pvBLYPnV" class="img-fluid" 
alt="CLRSWY"></p>

## <p style="background-color:#FDFEFE; font-family:newtimeroman; color:#9d4f8c; font-size:100%; text-align:center; border-radius:10px 10px;">WAY TO REINVENT YOURSELF</p>

___
"""